#### 1、定制化主题色
#### 2、全局主题切换（一键换肤）
#### 3、UI 标准化，ModelX-UI 库（包含各种各样定制化项目中常用的业务组件）

#### 4、添加全局水印配置，水印文字根据设定宽度自动换行
#### 5、组织架构树大量数据懒加载和批量加载
#### 6、菜单配置功能
#### 7、一键生成模块
#### 8、地图


```
第三点
分为3步

1、颜色，字体，间距等基本元素的标准化
2、产品基础组件标准化
3、业务组件标准化
```

<!-- 从1到3 从单个插件逐步做成一个标准化的库 -->
#### 1、定制化主题色
#### 2、全局主题切换（一键换肤）
#### 3、UI 标准化，ModelX-UI 库（包含各种各样定制化项目中常用的业务组件）


#### 1、定制化插件主题色
<!-- 修改日期组件定制的样式 -->
1、组件库，组织形式是一个组件一个 package 里面包含 组件的样式和各种 js 文件；
2、定位到需要修改样式的部分，直接修改 组件样式的 scss 参数；
3、修改组件之后，打包新的定制包，直接在项目中引用；

#### 2、全局主题切换（一键换肤）
<!-- 
换肤分为2部分
1、切换背景图片
2、切换 参数，根据 class 名称加载
 -->

1、全局挂载获取主题以及图片的方法
2、因为项目中有背景图片的部分，所以根据不同的主题，在主题目录下，新建各种对应的模块，切换到不同的主题的时候，自动获得不同主题下的图片；
3、点击主题切换按钮，将 theme 直接存储在 store 中，以便全局都能使用
4、获取不同的 theme 主题之后，获取不同的样式文件

#### 3、UI 标准化，ModelX-UI 库（包含各种各样定制化项目中常用的业务组件）
1、根据历史定制的项目，提取共性，提炼出定制化的模块
2、提取标准化定制的颜色
包括，小标题，边框，大标题，表头，列表，图表，dashboard 页面，tab 切换组件，页面顶部导航，左侧导航，右侧内容区域，icon 样式

#### 4、添加全局水印配置，水印文字根据设定宽度自动换行
1、全局水印配置页面
配置内容：
1）、是否需要水印，哪些模块页面出现水印，哪些页面不出现水印
2）、哪些内容出现在水印上面，警号,Id,日期，用户姓名，特殊宣传语
3）、水印的透明度，一行显示几个，一列显示几个，偏转角度

显示水印主要算法

```javascript
1、创建画布 
cosnt canvas = document.createElement('canvas');
2、创建 2d 绘图对象
const ctx = canvas.getContext('2d');
3、清理画布（通过将区域中的元素设置完全透明的黑色，达到擦除区域中元素的目的）
ctx.clearRect(0, 0, this.innerWidth / xCount, this.innerHeight / yCount);
4、填充画布的颜色和不透明度，设置字体和画布旋转角度
5、对要显示的水印文本进行处理
主要使用 ctx.measureText 测量要显示的字符串的长度，更具每一块画布的宽度进行切分，直到超过长度的水印的文字能分行显示完整；
6、使用 ctx.fillText() 填充文字
7、使用 canvas.toDataURL() 转化成base64 格式的图片，作为水印区域的背景
```

#### 5、组织架构树大量数据懒加载和批量加载
<!-- 主要技术要点：懒加载、逐级加载、滚动加载、只显示可视区域的树节点，需要和服务端约定好接口 -->
<!-- 预设每一个节点高度为 30px，视口高度是 300px， startIndex, endIndex -->
<!-- 节点数据结构
{
    name:'',
    nodeKey:'',
    id:'',
    parentId:'',
    childrens:[],
    z:'', // 层级用来显示缩进
    index: '', // 由前端生成用于
}
 -->
1、服务端返回组织结构树的一级节点，根据视口高度渲染，计算出能够渲染多少节点, 同时设置节点开始和结束索引位置
2、将服务端返回的节点数组，变成一层的的节点，为 treeNodes 并生成index，和缩进；
3、滚动视口，得到滚动的高度 offsetTop，向上滚动多少，重新计算 开始的 startIndex,  offsetTop / 30, 加上视口的高度 clintHeight /  30， offsetTop / 30 + clintHeight / 30 为开始结束索引，从 treeNodes 获取展示节点，在视口中展示；
4、点击一级节点，服务端返回当前节点的子节点，遍历 treeNodes，根据当前点击的节点，生成新的 z 和 index, 并且将之后的节点索引进行重新计算；
5、将重新整理后的子节点，在 treeNodes 中找到，当前点击的节点的索引，并插入其中，得到新的 treeNodes
6、重复第三个步骤，将页面渲染出来；


#### 6、菜单配置管理后台功能

1、添加菜单，配置菜单的名称，icon, 类型，不依靠服务端人员通过运行 SQL 语句就可以生成对应的菜单
2、前端运行 npm run add:module module-test，生成模块名为 module-test 模块，和菜单名称对应；


#### 7、一键生成模块
<!-- npm 库 json-templater/string 替换js 或者 json 的 变量 -->
1、运行 node 命令，npm run add:module module-test 生成，通过模板生成对应的文件和文件夹，
节省生成模块的时间；


#### 8、地图
基于openLayer 进行封装，分别实现了地图视图层、地图图源瓦片层、相机标注层，设备聚类层、点位层，手势层，圈图层




