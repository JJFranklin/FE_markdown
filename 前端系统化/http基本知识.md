- HTTP 基本特性

  1、http是超文本传输协议的简称，特点是简单的，无状态的通信协议

  ```
  无状态：服务器和客户端之间通过http协议进行通讯，服务器不会保存之前建立连接的状态。
  比如发送一个请求，这是一个全新的请求，并不会记住上一次是谁发送的请求或者请求的状态。
  可以通过cookie和session结合的方式解决。
  ```

  2、http 报文

  http 报文由报文首部和报文主体组成。

  请求报文首部：请求行（请求方法，协议以及版本 ，URL 资源定位符地址），请求首部字段；

  响应报文首部：请求行（协议以及版本，状态码），响应首部字段；

  报文实体：请求参数，返回的响应数据

  首部字段
  content-type:json
  content-encoding:gzip
  cookie
  host
  cache-control

- HTTPS 基本特性

  HTTPS 是超文本安全传输协议的简称，特点是安全。

  安全是和http 相比。

  1、http是直接和tcp进行通信，https 和tcp 之间多了一层ssl层，对通信链路和内容进加密。

  | HTTP | HTTPS |
  | ---- | ----- |
  | TCP  | SSL   |
  |      | TCP   |

  2、http 通信数据传输是透明的，不安全的，明文的，可以获取到传输的数据，即使加密了也可以获取到加密的数据。

  https 对整合通信链路都进行了加密，同时也对通信的内容也进行加密。

  3、加密方式：对称加密，非对称加密

  > 对称加密：客户端和服务器共享一个共享密钥，对加密内容进行解密和加密
  >
  > 缺点：共享密钥在传输过程中容易被获取，不安全
  >
  > 非对称加密：服务端和客户端各自保留私钥，通过公开密钥进行加密，使用私钥进行解密
  >
  > 缺点：公开密钥的传输也容易被获取，篡改。

  4、认证证书

  认证证书是为了解决通信过程中，公开密钥和报文内容被篡改和通信双方身份确认的问题。

  认证证书由可靠的第三方机构颁发，通常已经嵌入到浏览器中。

  获取过程

  > 1、服务器运营方向第三方机构申请证书，第三方机构审核通过后会将公开密钥和数字签名一起放到证书中,发送给服务器运营方；
  >
  > 2、服务器申请的证书发送给客户端，客户端根据证书的数字签名确认服务端的真实身份，通过之后拿到公开密钥；
  >
  > 3、客户端确认了服务端的身份之后，发送信息给服务端，服务端拿到信息之后，通过算法计算传过来的信息，得到验证信息，
  >
  > ​	是否一致，一致，服务端确客户端也是可靠的。之后就进行通信。
  >
  > 3、在后面的通信中就会使用公开密钥加密，通过私钥进行解密。

  5、缺点：由于多了SSL对数据进行加密解密的过程，会耗费时间和内存等硬件资源

  6、解决方式

  > 对于敏感的信息，使用非对称加密的方式；
  >
  > 对于非敏感的信息，使用对称加密的方式，对称加密共享密钥传输，可以采用证书的方式，防止篡改，保证安全性；

- 缓存机制

  强缓存和协商缓存

  强缓存

  > 客户端发起请求，判断Cache-control（通用首部字段） 中的max-age 或者Expires（实体首部） 字段，如果都没过期，直接命中缓存。如果没有命中，进入协商缓存。

  协商缓存

  >判断字段：last-modify(服务端)/last-modify-since(客户端)，if-non-match(客户端)/etag(服务端)
  >
  >1、客户端第一次向服务器发起请求，服务端会在响应部分带上last-modify 或者etag 字段的值；
  >
  >2、客户端再次发送请求时，会将last-modify或者etag 的值写入到请求首部字段对应last-modify-since和if-non-match字段中；
  >
  >3、服务端会比较last-modify和last-modify-since或者etag和if-non-match大小是否相等，相等直接命中缓存，返回304。不相等，服务器响应请求，返回新的数据；
  >
  >last-modify：优点是产生简单，记录资源的修改时间。缺点是，记录的最小时间单位是秒级别，对秒以下的改动无法感知。
  >
  >etag：优点是响应敏感，不依赖时间，只依赖于数据实体的变化，有变化就会重新响应请求。缺点是，产生复杂，根据实体数据的内容等特性，产生的加密字符串。
  >
  >对比优先级，响应敏感比较重要，一般使用etag

  TCP/IP 的三次握手
  目的：为了确定服务端和客户端的收发能力都是正常的

  ```javascript
  1、第一次握手：客户端给服务端发送数据，服务端收到了，服务端知道客户端发送能力正常，自己的接受能力正常；
  2、第二次握手：服务端给客户端发送数据，客户端收到了，客户端知道服务端发送和接收能力都是正常的，自己的发送能力和接收能力是正常的
  3、第三次握手：客户端发送数据包给服务端，服务端收到了，服务端知道客户端的的收发能力是正常的，自己的收发能力也是正常的，可以建立正常的通信连接。
  ```

状态码

```
200 请求成功
301 永久重定向
302 临时重定向
304状态码: 客户端有缓存情况下服务端的一种响应
```

跨域 是客户端的行为
协议，端口，域名 三者其中一个不同就是跨域
jsonp 支持支get 请求

cors 需要服务端支持
Access-Control-Allow-Origin:""



------

Http 基本知识补全



1、状态码

302：暂时重定向，网址暂时不使用，网址不会做缓存优化。
301：永久重定向，网址永远不使用，服务器返回新的地址，并将新的地址缓存下来，在第二次进行访问的时候，会直接访问上次缓存的地址。
304：客户端有缓存情况下服务端的一种响应
401：(未授权) 请求要求身份验证
403：(禁止) 服务器拒绝请求
404：Not Found 没有找到资源


500：服务器错误
502	Bad Gateway： (错误网关) 服务器作为网关或代理 

2、http 的队头阻塞

原因：每个域名都有连接数的限制，http 是`请求-应答`的形式，发起一个请求之后，会相应，其他的请求就会等待，造成阻塞；

解决方式：提供多个连接，当一个处于`请求-应答`的时候，另一个请求，会使用其他的连接，不造成连接阻塞。

提供多个连接的方式：域名分片、并发连接

- 在主域名中提供多个二级域名，就可以提供多个连接数，降低阻塞；
- 静态资源使用cdn 的方式存储，既可以加快访问的速度，又可以提供更多的连接数。



3、http 传输 数据

定长内容

通过content-length 属性进行进行控制，属性值小于内容长度，会截断内容；

不定长的内容

需要设置 Transfrt-Encoding：chunked 

会持续传输不定长的内容。



4、大文件传输

请求头设置 Range (content-range、accept-range)属性，设定传输内容的范围 

1-99/1000：1-99个字节，总字节数是1000

4.1、断点续传




5、cookie：缓存

- 携带访问上下文信息，携带的数据量较小，4kb 左右；
- 有同域名的限制，只能访问同域名的cookie，通过domain设置访问的域名结尾要一致，path 设置哪些域名下的哪些路径可以访问
- cookie的时效性通过max-age ，expire ，不匹配，就会删掉cookie;
- 携带了敏感信息，容易被窃取，设置httpOnly，防止js 不能读取更改cookie ;
- 还可以设置 sameSite:strict 防止第三方请求携带cookie



6、http 代理

相当于在客户端和服务端之间有个中介，客户端不需要知道服务端，服务端不需要知道客户端；

设置代理的好处

- 负载均衡：客户端的大量请求到达代理的时候，代理可以根据请求的不同情况分配到不同的服务器，主要用在反向代理场景。

- 代理缓存：cache-control: pubulic 允许代理可以缓存，

  s-maxage 表示可以在缓存在代理服务器存放的时间，

  Only-if-cache：只能从代理服务器获取缓存，不能从服务端获取缓存

  客户端没有必要每次通过服务器获取缓存，直接从代理获取缓存，减少服务端的访问负担。

- 安全：可以过滤不需要的http请求，以及不安全的ip 地址



7、跨域

产生原因：浏览器的同源政策的限制，客户端发送了请求，服务端拿到了请求，客户端没有拿到返回的数据。

方式：cros、jsonp

cros : 应对简单请求和非简单请求不同

服务端响应，会添加 Access-Control-Allow-origin 指定哪些地址是可以访问

简单请求

- 请求方式：get、post、put、head
- 请求头首部字段：content-language、content-type(application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain)、accept、accept-language
- 只会请求一次

非简单请求

- 会有两次请求，一次是预请求，检查请求是否符合规范，比如说是否满足跨域条件，是否需要携带身份验证（cookie）

  options 预请求之后，符合条件，会发送正式的请求。

  

8、会话复用

sessionID：服务端和客户端同时存着id，客户端发送请求的时候，通过cookie将sessionId 传输到服务端，服务端检查Id 是否过期，没有过期直接，恢复会话状态(带上上次会话的上下文)

sessionTicket：将会话压力分摊给客户端，服务端将sessionTicket 发送到客户端，客户端收到，计算sessionTicket 没有过期，客户端恢复会话。

9、HTTP 2

10、session 和 cookie
session 和 cookie 分别是服务端和客户端存储会话状态的两种机制。
cookie 存储在客户端，单个存储量有限4kb 大小，可以使用max-age 设置过期时间，只能进行同源限制访问；
session 存储在服务端，服务端根绝客户端的访问信息生成唯一识别为sessionId，然后返回给客户端，客户端拿到sessionId之后，将sessionId 存储在cookie 中，之后在客户端访问服务器的时候会带上，服务端识别之后，确定是有效的客户端，进行其他操作；

11、从url 到页面显示出来，整个过程
1、


